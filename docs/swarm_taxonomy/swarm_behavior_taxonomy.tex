\documentclass[]{article}

\usepackage{xargs} 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=purple,backgroundcolor=purple!25,bordercolor=purple,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

\usepackage{graphicx}
\usepackage{auto-pst-pdf}
\usepackage{graphviz}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{multicol}

%opening
\title{A Hierarchy of Swarm Robot Behaviors}
\author{Abraham Shultz}

\begin{document}

\maketitle

\begin{abstract}
Because robotic swarms consist of multiple robots, there are behaviors available to them that are not available to single robots. Also, swarms present the possibility of behavior at a greater scale than individual robots, by having emergent behaviors of the swarm implied, rather than explicitly defined, at the level of individual robots. These multiple levels of behavioral organization give rise to multiple, inter-related possible behaviors that a swarm of robots can exhibit. This paper examines the available behaviors starting from minimal assumptions about the swarm, and examines possible other families or heirarchies of behaviors that arise when those assumptions are not in force. It also proposes mechanisms for unifying swarm states that develop under suboptimal network conditions. 

\end{abstract}

\section{Introduction}

For the purposes of this paper, behaviors differ from ``actions''. 
An action, such as sensing or moving forward, does not have a context, whereas behaviors are contextualized by interaction with other members of the swarm or the environment.
For example, the swimming of fish is an action, but when a group of fish swim close together in the same direction, this schooling is a behavior. 
Examined individually, each fish is simply swimming, but their attention to the other fish around them and reaction to it while swimming makes up the behavior of schooling. 

Numerous papers provide catalogs of primitive behaviors for robots 
The descriptions of these behaviors as ``primitive'' is sometimes meant to indicate that they are building blocks of more complex behaviors, or that they are not decomposable into smaller behaviors themselves. 
Other papers describe behaviors as primitive because while the behavior does not complete a task in itself, it can be combined with other behaviors or actions to perform a useful task. 

Designating some behaviors as primitive, while others are regarded as more advanced or complex, implies the existence of a hierarchy of behaviors, where complex behaviors are composed of more primitive behaviors, with the most primitive behaviors being closer to actions, as defined above. 
The purpose of this paper is to explore which behaviors are available or not from given sets of basic actions.
Such exploration is useful for creating a catalog of primitives that can be used in a compositional approach to program generation, both to define the primitives out of which programs can be composed, and provide some degree of assurance that these primitives can cover the space of possible tasks required from the swarm. 

\section{When We Say ``Swarm Robots''...}

Typically, a robot swarm consists of cooperating, autonomous robots with local sensing and communication and without central control or global information, situated in an environment that they can sense and modify \cite{brambilla2013swarm}.
The cooperation element of this definition is important, as a swarm may be expected to perform actions as a group that they cannot perform as single individuals \cite{csahin2004swarm}. 
These actions could be as simple as covering an area with sensor fields of vision, or as complex as moving an object from one point to another as a team. 
The mobility of the agents also makes swarm robotics distinct from amorphous computing or sensor mesh networks, although swarms also take inspiration and techniques from those fields.  

Numerous papers have proposed taxonomies of swarm robots, Brambilla \textit{et al}. provide an overview of these \cite{brambilla2013swarm}. 
This paper is focused instead on the interrelationships of the behaviors available to a swarm, and the assumptions that those behaviors are predicated on. 
Examining these assumptions may reveal unexplored regions of the space of possible swarm configurations. 

%TODO cite work on moving in formation as related to, but not entirely required for, caging manipulation

\section{Lists of Swarm Behaviors}

One possible list of primitives is disperse (no other nodes within distance d), general disperse (no more than n nodes within distance d), clump/cluster, attract to location, swarm in a direction, and scan area \cite{evans2000programming}.

McLurkin proposes a large set of behaviors, broken into categories by the number of robots involved, but also grouped into six groups: motion, navigation, dispersion, clustering, orientation, and utility.

McLurkin uses the term ``primitive'' to refer to behaviors of a single robot, ``pair behaviors'' for two robots, and group behaviors for more than two robots. 
Under the proposed distinction between actions and behaviors above, the motion group is composed only of actions except for Avoid Bump, the collision avoidance behavior. Move Arc, Move Forward, Rotate To Angle, and Move Stop are all actions. 
Move Arc moves the robot on an arc, composed of forward and rotational velocity. Move Forward, Rotate To Angle, and Move Stop are special cases of Move Arc, with, respectively, the rotational, translational, or both velocities set to zero. 
 
\cite{mclurkin2004stupid}.
\begin{multicols}{2}
	\begin{enumerate}[noitemsep]
	\item Motion
		\begin{enumerate}[noitemsep]
		\item Move Arc
		\item Move Stop
		\item Move Forward
		\item Move By Remote Control
		\item Avoid Bump
		\end{enumerate}
	\item Orientation
		\begin{enumerate}[noitemsep]
		\item Orient for Orbit
		\item Orbit Robot
		\item Orient to Robot
		\item Match Robot Heading
		\item Follow Robot
		\end{enumerate}
	\item Navigation
		\begin{enumerate}[noitemsep]
		\item Follow the Leader
		\item Orbit Group
		\item Navigate Gradient
		\end{enumerate}
	\item Clustering
		\begin{enumerate}[noitemsep]
		\item Cluster On Source
		\item Cluster With Breadcrumbs
		\item Cluster Into Groups
		\end{enumerate}
	\item Dispersion
		\begin{enumerate}[noitemsep]
		\item Avoid Robot
		\item Avoid Many Robots
		\item Disperse From Source
		\item Disperse From Leaves
		\item Disperse Uniformly
		\end{enumerate}
	\item Utility
		\begin{enumerate}[noitemsep]
		\item Detect Edges
		\end{enumerate}
	\end{enumerate}
\end{multicols} 


Nagpal proposes eight biologically inspired primitives for composing higher level behaviors \cite{nagpal2004catalog}.
 
\begin{enumerate}[noitemsep]
\item Morphogen gradients and positional information
\item Chemotaxis and directional information
\item Local inhibition and local competition
\item Lateral inhibition and spacing
\item Local monitoring
\item Quorum sensing and counting
\item Checkpoints and consensus
\item Random exploration and selective stabilization
\end{enumerate}

Morphogen gradients use local communication with hop counting to create a gradient from a source. 
The source robot transmits a message with a hop count of 0; other robots retransmit the message when they receive it, incrementing the hop count. 
As a result, the hop count becomes a rough proxy for distance from the source. 

Chemotaxis and direction is implemented in terms of morphogen gradients, by allowing each robot to query its neighbors about their hop count/morphogen intensity. 
This allows estimation of the direction of the local gradient, and so orientation towards or away from the source. 

Local and lateral inhibition have a large collection of possible variants and applications. 
Generally, they are used for electing individuals from the group. 
Nagpal suggests that each agent start from a random number and count down, with the agent that hits zero first becoming the elected individual. 
The elected individual broadcasts a message that suppresses all the robots that receive it from electing themselves. 
In a large group, a random countdown can lead to ties.
If two robots elect themselves within a time window smaller than that required for the suppressing message to propagate between them, they will both think they are leaders.
Self-election timestamps could be used as tiebreakers in this case. 
McLurkin suggests using globally unique robot IDs included in the suppression message, with each robot being suppressed if its ID is higher than the ID in the suppression message.
This can still have ties while the gradient propagates, but will converge to one elected robot.
 
Local monitoring uses heartbeat messages between local agents to keep track of the presence and activity of those neighbors. Failure to receive a message could trigger a response, such as moving to occupy a previously-occupied area to maintain sensor coverage.

Quorum sensing uses the number of agents in an area, as measured by morphgen signals, to determine when enough agents are present to perform an action. 
Checkpointing is a closely related behavior, where all agents that can detect if a desired condition is met emit a signal until they detect the condition is met. 
When all agents agree that the condition has been satisfied, signals indicating that it is not will cease. 
Checkpointing can be used to perform sequences of actions, provided that the robots can detect the desired transition point. 

In addition to primitive behaviors, there are catalogs of higher level behaviors. 
Brambilla \textit{et al}. group collective behaviors into four classes: spatially-organizing behaviors, navigation behaviors, collective decision-making, and other collective behaviors.

\begin{enumerate}[noitemsep]
\item Spatially-organizing
	\begin{enumerate}[noitemsep]
	\item Aggregation
	\item Pattern Formation
	\item Chain Formation
	\item Self-assembly and Morphogenesis
	\item Object Clustering and Assembling
	\end{enumerate}
\item Navigation
	\begin{enumerate}[noitemsep]
	\item Collective Exploration
		\begin{enumerate}[noitemsep]
		\item Area Coverage
		\item Swarm-guided Navigation
		\end{enumerate}
	\item Coordinated Motion
	\item Collective Transport
	\end{enumerate}
\item Collective Decision-Making
	\begin{enumerate}[noitemsep]
	\item Consensus Achievement
	\item Task Allocation
	\end{enumerate}
\item Other Collective Behaviors
	\begin{enumerate}[noitemsep]
	\item Fault Detection
	\item Group Size Regulation
	\end{enumerate}
\end{enumerate}


Matari\'c suggested the behavior set of avoidance, safe-wandering, following, aggregation, dispersion, and homing, combined with summation of the behaviors or switching between them based on sensor precepts \cite{mataric1995designing}. For example, flocking is the summation of dispersion, aggregation, and safe-wandering, plus homing to provide the swarm with a direction to flock in. 

The use of homing as a driver of other behaviors may be why homing is present in Matari\'c's behavior set, but absent from the others. 
Homing is the ability to find a particular location or region. 
All of the other behaviors in these lists are executable at any location, and do not refer to a specific place. 
Homing, on the other hand, implies that the robot has a sense of location, so that it can orient towards home. 
Without such a sense, the only way for an individual robot to find home would be to be able to detect it, and to wander randomly until the robot arrives. 

There is substantial overlap between these lists. Matari\'c's avoidance is the same as McLurkin's Avoid Bump, in that they both give the robot the ability to move without colliding with other robots or the environment. 
Aggregation and clustering, area coverage and dispersion, swarm-guided navigation and morphogen gradient navigation are all similar pairs of activites. 
Brambilla \textit{et al}. differs from McLurkin \& Nagpal in that it is not explicitly inspired by biology and so includes implementations of behaviors using basis other than biological, such as virtual physics or probabilistic finite state machines (PSFMs). 
Furthermore, compostional approaches have been proposed in control-theoretic terms as well as pheremone or morphogen-based terms, so the process of composition of primitives can be viewed as a metastrategy for the creation of programs, rather than a process specific to pheremone robotics \cite{belta2007symbolic}.

For the purposes of this paper, the underlying metaphor of the implementation of the behavior is not of primary relevance, as long as the behavior remains the same. 
However, different metaphors may require different assumptions about the available sensor information for each robot, and so result in a different range of basic behaviors being available to the swarm. 
Further, it seems that there is no swarm so minimal that someone hasn't found a way to get useful work out of it.  
If the robots can determine whether they have a line of sight to a goal, they can collaborate to push an object to the goal by only pushing on the side of the object if the goal is obscured by the object \cite{chen2015occlusion}. This works well for convex objects, but certain concave objects can be shown to be pushed away from the goal under this scheme. 
This behavior can be implemented by switching between random walking and phototropism based on whether the robot is pressed against an object, and so doesn't even require a general-purpose computer, just robots tall enough to see over the object when they are on the side away from the goal. 
A group of robots can rendezvous at a single location without communication or localization, but with the ability to detect another robot within its field of view \cite{yu2012rendezvous}. However, this paper makes some assumptions, such as the assumption that robots that are close enough will merge, that are not supported by the current state of the art. 

Because some apparently complex behaviors can be implemented on relatively trivial robots by making certain assumptions about the robots or the area that they are in, the remainder of this paper will focus on behaviors that could be implemented on a general abstract robot. 
This assumption is made with the understanding that by specializing the sensors of the robot, more specific tasks could be accomplished. 
For example, dispersion on the general robot is defined as dispersing so that no robot is within less than a fixed distance of any other robot. 
By adding a sensor that determines if the robot is within a desired area, area coverage can be specified from general dispersion. 
 
The general robot is mobile, and communicate locally. 
No restriction is placed on its ability to store messages from other robots or state information from those messages. 
Local communication refers to the ability to communicate with some subset of the swarm.
Depending on the implementation, particularly radio vs. infrared, this communication may depend on a clear line of sight between the robots.
For the general robot, the implementation details are not important. 

Determining the base set of behaviors for the swarm is difficult. 
Ideally, the base set covers all the desired tasks for the swarm through composition of base set behaviors with specializing sensors as described above. 
Since the set of possible desired tasks is unconstrained, there is no known set of behaviors that could cover all possible tasks. 
However, the convergence of multiple suggestions for behavior libraries implies that aggregation, dispersion, formation of patterns (particularly chains and arbitrary polygon formations), formation of navigational structures (such as beacon selection, gradients, and distributed coordinate systems), and distributed decision making are likely candidates for inclusion in a behavioral library sufficient to perform many tasks.  

\section{Pheremone Metaphors}

\subsection{Aggregation}

Aggregation in the general sense can be implemented simply by having robots attempt to minimize the distance between themselves and other robots. 
This form of aggregation can be implemented without communication, so long as robots can detect the distance to their neighbors. 
However, this simple form is also prone to causing the robots to form more than one cluster, as there is no guarantee that all robots will initially move to the same point. 

Aggregation in robotic swarms using a pheremone or morphogenic metaphor can be accomplished by having a robot at the desired location (the source) broadcast a message that indicates that nearby robots should come towards it. 
Nearby robots also broadcast the message, incrementing a hop count, and discarding any messages with a higher hop count than the lowest they have received. 
This rule results in all robots that can communicate eventually having a hop count value that indicates their distance, in hops, from the lowest robot. By querying their neighbors, each robot can determine the direction towards the source (towards those neighbors with lower hop counts) and so move towards the source. 

This behavior relies on the formation of a navigational structure, the gradient of message hop counts, as well as some ability to determine where the neighbors are located. These functions are covered in more detail in section \ref{pheremone_nav_struct}.

\subsection{Dispersion}

Dispersion is the inverse of aggregation, where each robot attempts to spread out from others, usually attempting to maintain some condition such as having no robots within a fixed distance. 
Typically, dispersion is intended to maximize area coverage without causing the robots to be so far apart that they can no longer communicate with each other. 
As with aggregation, dispersion can be implemented simply if the robots have the ability to detect each other's distance. 

In pheromone robotics, each robot can emit a repellent pheromone with a hop count that is rebroadcast by each robot that receives it, decrementing the hop count. 
Once the hop count reaches zero, the retransmission ends. 

%TODO find something that doesn't use range sensors or direction sensors and cite that

\subsection{Chain Formation}

\subsection{Polygon Formation}

\subsection{Navigational Structures} \label{pheremone_nav_struct}

Communicating robots can arrive at a consensus coordinate system using trilateration based on range sensors \cite{cheng2005robust}, or use lateral inhibition to select individual robots to serve as beacons which create gradients for trilateration via hop counts \cite{nagpal1999organizing}.
Robots with a consensus coordinate system can perform range and bearing calculations in relation to each other by communicating.
Rather than directly determining range and bearing from sensors, the communicating robots exchange their coordinates, and calculate the ranges and bearings from their positions. 

Assuming that the robots have unique identifiers, the range and bearing provided by the consensus coordinate system provides the other basic functionality needed to perform any of the behaviors from Stupid Robot Tricks \cite{mclurkin2004stupid}.
The behaviors of forming and navigating gradients and orbiting the edge of a group of robots, combined with group-based localization, allow Kilobots to form patterns much larger than the individual robots or their sensing ranges \cite{Rubenstein795}.

Even if the robots do not start with unique identifiers, the formation of a consensus localization framework will provide one.
Assuming that only one robot can be in a location at a time, the robots can use their initial location as a unique identifier. 
However, this assumes that the robots are all members of the same coordinate system.
If the initial configuration of the robots is as more than one disconnected network, separated by regions wider than the robots can communicate across, they may arrive at multiple coordinate frames.


\subsection{Decision Making}

\section{Evolved Behaviors}

\subsection{Aggregation}

\subsection{Dispersion}

\subsection{Chain Formation}

\subsection{Polygon Formation}

\subsection{Navigational Structures}

\subsection{Decision Making}

\section{Virtual Physics Metaphors}

\subsection{Aggregation}

\subsection{Dispersion}

\subsection{Chain Formation}

\subsection{Polygon Formation}

\subsection{Navigational Structures}

\subsection{Decision Making}

\section{Control Theory}

\subsection{Aggregation}

\subsection{Dispersion}

\subsection{Chain Formation}

\subsection{Polygon Formation}

\subsection{Navigational Structures}

\subsection{Decision Making}

\section{Probablistic Finite State Machines}

\subsection{Aggregation}

\subsection{Dispersion}

\subsection{Chain Formation}

\subsection{Polygon Formation}

\subsection{Navigational Structures}

\subsection{Decision Making}

%\section{Non-communication}
%
%Communication, in addition to being unicast, multicast, or broadcast, can also be implicit or explicit. 
%Explicit communication is the sending of a message with some informational content between robots. 
%Implicit communication is the conveying of information between robots without sending a message, by performing actions that alter the environment in a way that the robot receiving the communication can detect. 
%
%Communication via altering the environment is called stigmergy.
%The TERMES robot swarm uses only local sensing of the environment, combined with local rules, to collaboratively construct structures from blocks \cite{werfel2014designing}. 
%The placement of new blocks provides stigmergic signals to other robots, when they arrive at the location of the new blocks. 
%Robots with the ability to measure the motion of an object can collaborate to move it without communicating with each other \cite{wang2015multi}. 
%In this case, detected motions of the object being moved are a form of communication between the robots, in that they convey information about the actions of the other robots. 
%
%The morphogen gradients and hop-counting methods discussed earlier have a substantial overlap with pheromone-based robotics, where robots can release a chemical into the environment (usually via some non-chemical method, such as IR broadcast, but for an exception, see \cite{hayes2001swarm}). 
%The robots can release and react to pheromones in the environment, and so there is an implicit communication via stigmergy, but no explicit agent-to-agent communication. 
%Pheromone approaches can guide the construction of objects, even if the individual swarm members have no memory, no communication, and only local perception \cite{mason2003programming, wawerla2002collective, bowyer2000automated}.
%The agents engaged in the construction move at random, and take actions governed by their individual perception of environment at present time. 
%The addition of communication between systems and memory of the state of the world will improve the efficiency of the system, but not having explicit communication does not prevent it from functioning.

%\section{No Unique Names}
%
%Globally unique robot identifiers make some tasks easier, such as detecting circumnavigation of an object by using a stationary robot as a beacon. 
%If a transient or local names is used, the moving robot may fail to re-identify the beacon, while non-unique names could lead to multiple incorrect identifications of the beacon.
%
%%todo what does not having each level of naming _prevent_?
%
%The naming of robots within a swarm is not a binary distinction. Robots can have no awareness of the distinction between robots and other obstacles in the environment, be able to distinguish other robots, be able to determine the type of other robots, or be able to recognize specific other robots, either by local/temporary identifiers or permanent/global identifiers. 
%
%At the most basic, robots in the swarm are completely unaware of each other, in that they make no distinction between other swarm robots and obstacles within the environment. 
%
%With slightly better sensing, the robots can identify whether an object is another robot or a non-robot object. The TERMES swarm uses ultrasound for detecting the structure on which they operate, but can also detect other robots using ultrasound nearby. They do not communicate via ultrasound, and their interaction is limited to yielding to other robots on the same path \cite{werfel2014designing}. Reynolds' ``boid'' flocking algorithm also uses the range to other boids and to non-boid objects, without explicitly identifying individuals, which implies that swarm behaviors such as aggregation and dispersion will function well when taking into account the presence of other swarm members without considering their identity \cite{reynolds1987flocks}. 
%
%In the case of heterogeneous swarms, it may be useful to have robots be able to identify what class or type of robot another robot is, but have no need to know that it is a specific instance of that class. The Swarmanoid project uses mobile foot-bots, flying eye-bots, and gripper-equipped hand-bots to perform tasks cooperatively. The mechanism of this cooperation does not rely on individual identities for the robots, but allows them to communicate with each other locally, and transfer information based on the type of robot requesting it \cite{ducatelle2011self}. 
%
%For temporary collaboration, robots could develop local names or identities. 
%However, this approach seems absent from the literature, perhaps because the effort of negotiating local names or identities when needed is lower than the effort of simply having pre-generated names. 
%Nagpal's catalog specifically calls out the possibility that there may be too many agents to name, but provides mechanisms for election of ``leaders'' for specific functions \cite{nagpal2004catalog}. 
%Leadership, in this case, becomes a sort of temporary identity for the robot, which distinguishes it from all non-leaders, and possibly uniquely as a particular leader. 
%In cases like the beacon example above, this temporary quality is sufficient.  
%
%Globally unique identifiers are convenient, and not difficult to implement for moderately sized swarms (although the author has had several experiences with MAC addresses of commercial hardware being not as unique as they should be).
%However, global unique identifiers lack biological plausibility. 
%It is clear that, for example, ants can recognize the distinction between members of their own colony and outsiders, and the distinct castes within their colony, by the smell of chemicals on the surface of the other ant \cite{sharma2015cuticular}. 
%While this is an impressive range, it seems unlikely that ants can identify each other as specific individuals, with the possible exception of the queen, due in large part to the identity chemicals of the ants being shared via contact within the hive \cite{bos2012recognition}. 
%
%\section {Sensing and Reacting to the Environment}
%
%McLurkin assumes that all swarm robots have a simple obstacle avoidance behavior that causes them to not hit each other or obstacles in the environment \cite{mclurkin2004stupid}.
%This assumption, or this base behavior, is present in other systems as well \cite{werger1999cooperation, mataric1995designing}
%
%Requiring tasks like patrolling an area, sensor overwatch of an area, moving an object all require the ability to recognize the area or the object. Without this sensing, regions of the environment cannot be treated as special. 
%Matari\'c refers to this ability as "homing"\cite{mataric1995designing}.
%
\bibliography{../proposal/swarm.bib}
\bibliographystyle{apalike}

\end{document}

%\begin{figure}[h]
%	\centering
%	\digraph[scale=0.6]{BehaviorDependencies}{
%	
%		//edgeFollow [label="Edge Following"];
%		grad [label="Gradient Formation"];
%		local [label="Localization"];
%		move [label="Move Arc"];
%		avoid [label="Avoid Obstacles"];
%		orientToBot [label="Orient to Robot"];
%		head [label="Match Heading"];
%		follow [label="Follow Robot"];
%        avoidBot [label="Avoid Robot"];		
%		prepOrbit [label="Orient for Orbit"];
%		orbit [label="Orbit Robot"];
%		avoidMany [label="Avoid Many"];
%		disperseSrc [label="Disperse Source"];
%		disperseLeaves [label="Disperse Leaves"];
%		disperseUniform [label="Disperse Uniform"];
%		followLeader [label="Follow Leader"];
%		orbitGroup [label="Orbit Group"];
%		navigateGradient [label="Navigate Gradient"];
%		clusterSrc [label="Cluster at Source"];
%		clusterGroups [label="Cluster into Groups"];
%		detectEdge [label="Detect Edge"];
%		localInhib [label="Local Inhibition"];
%		lateralInhib [label="Lateral Inhibition"];
%		localMonitor [label="Local Monitor"];
%		quorum [label="Quorum Sensing"];
%		checkpoint [label="Checkpointing"];
%		randomExplore [label="Random Exploration"];
%		selectStable [label="Selective Stabilization"];
%		senseNeighborBearing [label="Sense Neighbor Bearing"];
%		senseNeighborRange [label="Sense Neighbor Range"];
%		interstitialAvoid [label="Aim Between Robots"];
%		
%		clusterGroups -> navigateGradient;
%		
%		clusterSrc -> follow;
%		
%		navigateGradient -> interstitialAvoid;
%		navigateGradient -> senseNeighborBearing;
%		navigateGradient -> move;
%		
%		orbitGroup -> orbitRobot;
%		orbitGroup -> senseNeighborRange;
%		
%		followLeader -> follow;
%		
%		disperseUniform -> senseNeighborBearing;
%		disperseUniform -> senseNeighborRange;
%		disperseUniform -> move;
%		
%		disperseLeaves -> avoidMany;
%		disperseLeaves -> grad;
%		
%		disperseSrc -> avoidMany;
%		
%		avoidMany -> senseNeighborBearing;
%		avoidMany -> move;
%		
%		orbit -> prepOrbit;
%		orbit -> move;
%		
%		prepOrbit -> orientToRobot;
%		prepOrbit -> senseNeighborRange;
%		
%		orientToBot -> senseNeighborBearing;
%		orientToBot -> move;
%		
%		head -> orientToBot;
%		head -> move;
%		
%		follow -> orientToBot;
%		follow -> senseNeighborRange;
%		follow -> move;
%		
%		avoidBot -> orientToBot;
%		avoidBot -> move;
%		
%		local -> grad;
%		local -> lateralInhib;
%	
%		navigateGradient -> grad;
%
%	}
%	\caption{Dependencies between behaviors}
%\end{figure}


